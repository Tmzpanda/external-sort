import random
import shutil
import os
from heapq import heappush, heappop


def generate_n_int_file(file_name, n):
    """
    :param file_name: file generated by this function
    :param n: number of random 4-byte integers (N in the given problem)
    output: integers.txt
    """
    nums = [bin(random.randint(0, 2 ** 32))[2:].zfill(32) for _ in range(n)]

    with open(file_name, 'w') as f:
        f.write('\n'.join(nums))

    f.close()


class ExternalSortOperator:

    @staticmethod
    def external_sort(input_file, memory, output_file):
        """
        split the large file into multiple small files that fits into in-memory sort
        then merge all the intermediate output small sorted files to get the final sorted file
        """
        ExternalSortOperator.sort_chunks(input_file, memory)
        ExternalSortOperator.heap_sort(output_file, memory)


    @staticmethod
    def sort_chunks(input_file, chunk_size):
        """
        :param input_file: large file to be sorted
        :param chunk_size: memory capacity (M in the given problem)
        output: tmp/
        """
        if os.path.exists('./tmp/'):
            shutil.rmtree('./tmp/')
        os.mkdir('./tmp/')

        f = open(input_file, 'r')

        chunk, arr = 1, ExternalSortOperator.read_n_int(f, chunk_size)
        # print(arr)
        while len(arr) > 0:
            ExternalSortOperator.sort_and_write(f'./tmp/sorted_{str(chunk)}', arr)
            arr = ExternalSortOperator.read_n_int(f, chunk_size)
            chunk += 1

        f.close()

    @staticmethod
    def heap_sort(output_file, chunk_size):
        """
        :param output_file: sorted large file
        :param chunk_size: size of intermediate small sorted file
        :output: output.txt

        Using heap to merge N/M intermediate small sorted file into the final large sorted file
        """

        fs = [open(f'./tmp/{f}', 'r') for f in os.listdir('./tmp/')]
        heap = []
        for i, f in enumerate(fs):
            heappush(heap, (f.readline(), i, 0))  # can be optimized with input buffer
        # print(heap)


        if os.path.exists(output_file):
            os.remove(output_file)

        f = open(output_file, 'a')
        while heap:
            val, i, idx = heappop(heap)
            f.write(val) if val.endswith('\n') else f.write(f'{val}\n')  # can be optimized with output buffer

            temp = fs[i].readline()
            if idx + 1 < chunk_size and temp:
                heappush(heap, (temp, i, idx + 1))

        f.close()


    @staticmethod
    def read_n_int(f, size):
        arr = []
        num = f.readline().rstrip('\n')
        while num:
            arr.append(num)
            if len(arr) >= size:
                break
            num = f.readline().rstrip('\n')

        return arr

    @staticmethod
    def sort_and_write(temp_file, arr):
        arr.sort()

        with open(temp_file, 'w') as f:
            f.write('\n'.join(arr))

        f.close()


if __name__ == '__main__':

    # generate n random 4-byte integers to a file
    input_file = './integers.txt'
    n = 10**4
    generate_n_int_file(input_file, n)

    # use external merge sort to write a sorted version of the file
    memory = 10**3
    output_file = './output.txt'
    ExternalSortOperator.external_sort(input_file, memory, output_file)

    # confirm the output file is sorted correctly
    arr = open(output_file, "r").readlines()
    print(f'Validate if output is sorted: {all(arr[i] <= arr[i+1] for i in range(len(arr)-1))}')
